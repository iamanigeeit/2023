"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[6297],{15769:(e,s,a)=>{a.d(s,{A:()=>t});const t=a.p+"assets/images/state_space_map-11c07cbe83c95b6f8f8e9915f832ee3e.png"},28236:(e,s,a)=>{a.d(s,{A:()=>t});const t=a.p+"assets/images/state_search_trees-50e520d5be514e114e428c84ef3da926.png"},44026:(e,s,a)=>{a.r(s),a.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>h,metadata:()=>t,toc:()=>m});const t=JSON.parse('{"id":"sm/state-space-search","title":"State Space Search","description":"State-space search is a technique that involves systematically exploring possible states within a state machine to find optimal solutions. This method is crucial for planning and problem-solving tasks, where the goal is to navigate from an initial state to a desired goal state through a series of transitions. In AI, state-space search is employed in various applications, such as automated planning in robotics, where the robot must determine the sequence of actions to achieve a specific task. For example, a robot navigating a warehouse to pick and place items uses state-space search to plan its path efficiently, avoiding obstacles and optimizing its route. Another application is in game AI, where state-space search helps in solving puzzles or strategizing moves. For instance, in chess, the AI explores different board configurations to determine the best sequence of moves leading to a checkmate. Additionally, state-space search is used in natural language processing for parsing sentences, where the AI systematically explores different syntactic structures to understand and generate coherent text. These examples illustrate how state-space search enables AI systems to make intelligent decisions by thoroughly examining all possible states and transitions to find the most effective solutions.","source":"@site/docs/08-sm/state-space-search.md","sourceDirName":"08-sm","slug":"/sm/state-space-search","permalink":"/2023/notes/sm/state-space-search","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"SM Abstract Base Class","permalink":"/2023/notes/sm/state-machine-abc"},"next":{"title":"Week 9: Visualizing and Processing Data","permalink":"/2023/notes/category/week-9-visualizing-and-processing-data"}}');var n=a(74848),i=a(28453),r=(a(28548),a(13358),a(73627)),c=a(53833);const h={sidebar_position:3},o="State Space Search",l={},m=[{value:"Goals",id:"goals",level:3},{value:"Introduction",id:"introduction",level:2},{value:"Defining State-Space Search",id:"defining-state-space-search",level:2},{value:"Search Trees",id:"search-trees",level:2},{value:"Class SearchNode",id:"class-searchnode",level:2},{value:"State Machine for State-Space Search",id:"state-machine-for-state-space-search",level:2}];function d(e){const s={admonition:"admonition",annotation:"annotation",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",math:"math",mermaid:"mermaid",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"state-space-search",children:"State Space Search"})}),"\n",(0,n.jsx)(s.p,{children:"State-space search is a technique that involves systematically exploring possible states within a state machine to find optimal solutions. This method is crucial for planning and problem-solving tasks, where the goal is to navigate from an initial state to a desired goal state through a series of transitions. In AI, state-space search is employed in various applications, such as automated planning in robotics, where the robot must determine the sequence of actions to achieve a specific task. For example, a robot navigating a warehouse to pick and place items uses state-space search to plan its path efficiently, avoiding obstacles and optimizing its route. Another application is in game AI, where state-space search helps in solving puzzles or strategizing moves. For instance, in chess, the AI explores different board configurations to determine the best sequence of moves leading to a checkmate. Additionally, state-space search is used in natural language processing for parsing sentences, where the AI systematically explores different syntactic structures to understand and generate coherent text. These examples illustrate how state-space search enables AI systems to make intelligent decisions by thoroughly examining all possible states and transitions to find the most effective solutions."}),"\n",(0,n.jsx)(c.A,{}),"\n",(0,n.jsx)(s.h3,{id:"goals",children:"Goals"}),"\n",(0,n.jsx)(s.p,{children:"By the end of this lesson, you should be able to:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["Apply breadth first search to perform ",(0,n.jsx)(s.strong,{children:"state-space search"}),"."]}),"\n"]}),"\n",(0,n.jsx)(s.admonition,{title:"Keywords",type:"keyword",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"state space search"}),", ",(0,n.jsx)(s.code,{children:"legal inputs"}),", ",(0,n.jsx)(s.code,{children:"state map"}),", ",(0,n.jsx)(s.code,{children:"graph traversal"}),", ",(0,n.jsx)(s.code,{children:"breadth first search"}),", ",(0,n.jsx)(s.code,{children:"queue"}),", ",(0,n.jsx)(s.code,{children:"path"}),", ",(0,n.jsx)(s.code,{children:"step"})]})}),"\n",(0,n.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,n.jsxs)(s.p,{children:["Previously we have learnt on how we can find data from a graph data structure. We implemented breadth-first search and explore depth-first search algorithm. We can look into this problem from a different angle as a state-space search. Instead of thinking about nodes and edges, we can see it as ",(0,n.jsx)(s.em,{children:"states"})," and ",(0,n.jsx)(s.em,{children:"transitions"}),". Each node can be thought of as one state and each edge can be thought of as a transition from one state to anther state. We can then apply graph algorithm for our state machines."]}),"\n",(0,n.jsxs)(s.p,{children:["But what does it mean of doing a state-space search? Remember that we attach every transition from one state to another state with an ",(0,n.jsx)(s.em,{children:"input"})," that moves that state machine from the current state to the next state. Doing a state-space search allows us to find a path or ",(0,n.jsx)(s.em,{children:"sequence of inputs"})," that bring us from a starting state to a goal state. This means that if I know my goal state of my machine, I can do a search what are the inputs needed to reach that state. This can be used to make our state machine more intelligent through ",(0,n.jsx)(s.em,{children:"planning"}),"."]}),"\n",(0,n.jsx)(s.h2,{id:"defining-state-space-search",children:"Defining State-Space Search"}),"\n",(0,n.jsx)(s.p,{children:"Let's first define our problem. We can model this state-space search problem as follows. Given the following information:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"a set of states the system can be in;"}),"\n",(0,n.jsx)(s.li,{children:"a starting state;"}),"\n",(0,n.jsx)(s.li,{children:"a goal test, which is a procedure that can be applied to any state, and returns the True if that state is the goal state;"}),"\n",(0,n.jsx)(s.li,{children:"a successor function, which takes a state and an action as input, and returns the new state that results from taking the action in that state;"}),"\n",(0,n.jsx)(s.li,{children:"and a legal action list, which is just a list of actions that can be executed in this domain\nthe problem is to find a sequence of input that brings us to the goal state given the starting state."}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Let's take a look an an example. Consider the case where we have the following states:"}),"\n",(0,n.jsx)(r.A,{path:a(15769).A,widthPercentage:"40%"}),"\n",(0,n.jsx)(s.p,{children:"We do not draw any arrow in the above diagram to simplify the drawing as we assume that the transition is bi-directional. This means that there is a transition from S to A and from A to S."}),"\n",(0,n.jsx)(s.p,{children:"In the above example, we have the set of states:"}),"\n",(0,n.jsx)(s.span,{className:"katex-display",children:(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mi,{children:"s"}),(0,n.jsx)(s.mi,{children:"t"}),(0,n.jsx)(s.mi,{children:"a"}),(0,n.jsx)(s.mi,{children:"t"}),(0,n.jsx)(s.mi,{children:"e"}),(0,n.jsx)(s.mi,{children:"s"}),(0,n.jsx)(s.mo,{children:"="}),(0,n.jsx)(s.mo,{stretchy:"false",children:"{"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mi,{children:"S"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mi,{children:"A"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mi,{children:"B"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mi,{children:"C"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mi,{children:"D"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mi,{children:"E"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mi,{children:"F"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mi,{children:"G"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mi,{children:"H"}),(0,n.jsx)(s.mi,{mathvariant:"normal",children:"\u2018"}),(0,n.jsx)(s.mo,{stretchy:"false",children:"}"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"states = \\{`S`, `A`, `B`, `C`, `D`, `E`, `F`, `G`, `H`\\}"})]})})}),(0,n.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6151em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"s"}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"t"}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"a"}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"t"}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"es"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,n.jsx)(s.span,{className:"mrel",children:"="}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,n.jsx)(s.span,{className:"mopen",children:"{"}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"S"}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"A"}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05017em"},children:"B"}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.07153em"},children:"C"}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.02778em"},children:"D"}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.05764em"},children:"E"}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.13889em"},children:"F"}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"G"}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mord mathnormal",style:{marginRight:"0.08125em"},children:"H"}),(0,n.jsx)(s.span,{className:"mord",children:"\u2018"}),(0,n.jsx)(s.span,{className:"mclose",children:"}"})]})]})]})}),"\n",(0,n.jsx)(s.p,{children:"We also need to know the starting state, so let's say state 'S' is the starting state. The goal test is a function that takes in a state as an input and returns True if that state is the goal state. So if we want to reach G starting from S, we can write the following goal test."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"def goal_test(state):\n    return state == 'G'\n"})}),"\n",(0,n.jsx)(s.p,{children:"We can also write it as a lambda function in Python as follows."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"lambda state: state == 'G'\n"})}),"\n",(0,n.jsxs)(s.p,{children:["The legal actions in this domain can be integers values like ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsxs)(s.mrow,{children:[(0,n.jsx)(s.mn,{children:"0"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mn,{children:"1"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mo,{children:"\u2026"}),(0,n.jsx)(s.mo,{separator:"true",children:","}),(0,n.jsx)(s.mi,{children:"n"}),(0,n.jsx)(s.mo,{children:"\u2212"}),(0,n.jsx)(s.mn,{children:"1"})]}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"0, 1, \\ldots, n-1"})]})})}),(0,n.jsxs)(s.span,{className:"katex-html","aria-hidden":"true",children:[(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.8389em",verticalAlign:"-0.1944em"}}),(0,n.jsx)(s.span,{className:"mord",children:"0"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord",children:"1"}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"minner",children:"\u2026"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mpunct",children:","}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.1667em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"n"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,n.jsx)(s.span,{className:"mbin",children:"\u2212"}),(0,n.jsx)(s.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.6444em"}}),(0,n.jsx)(s.span,{className:"mord",children:"1"})]})]})]}),", where ",(0,n.jsxs)(s.span,{className:"katex",children:[(0,n.jsx)(s.span,{className:"katex-mathml",children:(0,n.jsx)(s.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,n.jsxs)(s.semantics,{children:[(0,n.jsx)(s.mrow,{children:(0,n.jsx)(s.mi,{children:"n"})}),(0,n.jsx)(s.annotation,{encoding:"application/x-tex",children:"n"})]})})}),(0,n.jsx)(s.span,{className:"katex-html","aria-hidden":"true",children:(0,n.jsxs)(s.span,{className:"base",children:[(0,n.jsx)(s.span,{className:"strut",style:{height:"0.4306em"}}),(0,n.jsx)(s.span,{className:"mord mathnormal",children:"n"})]})})]})," is the maximum number of successors in any of the states. The maximum number of successors simply means the maximum number of degrees in the graph. We can find this number by looking at the node (or state) that has the largest number of edges. In this case, state 'D' has the largest number of edges, i.e. 4. So the legal actions are integer values: 0, 1, 2, 3. We can assign, for example, the following transitions:"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"input 0: transition from D to A"}),"\n",(0,n.jsx)(s.li,{children:"input 1: transition from D to B"}),"\n",(0,n.jsx)(s.li,{children:"input 2: transition from D to F"}),"\n",(0,n.jsx)(s.li,{children:"input 3: transition from D to H"}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Therefore, we also need a kind of transition maps. If our legal input is integer values, we can simply use a list where the index matches the transition. We can write our transition map as follows."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"statemap = {'S': ['A', 'B'],\n            'A': ['S', 'C', 'D'],\n            'B': ['S', 'D', 'E'],\n            'C': ['A', 'F'],\n            'D': ['A', 'B', 'F', 'H'],\n            'E': ['B', 'H'],\n            'F': ['C', 'D', 'G'],\n            'G': ['F', 'H'],\n            'H': ['D', 'E', 'G']}\n"})}),"\n",(0,n.jsx)(s.p,{children:"Notice in the above dictionary that we use list in the same sequence for state D, i.e."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"'D': ['A', 'B', 'F', 'H'],\n"})}),"\n",(0,n.jsx)(s.p,{children:"This allows us to have transition as specified above. For example,"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"statemap['D'][0] # returns state A\nstatemap['D'][1] # returns state B\nstatemap['D'][2] # returns state F\nstatemap['D'][3] # returns state H\n"})}),"\n",(0,n.jsx)(s.p,{children:"Given the above dictionary, we can simply write our successor function as follows."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"def statemap_successor(state, action):\n    return statemap[state][action]\n"})}),"\n",(0,n.jsx)(s.p,{children:"We may need some additional test to ensure that if an action that does not exist from that current state, it will just remain in the current state. For example, state 'G' has two transitions, we should expect the following."}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"print(statemap_successor('G', 2)) # output 'G'\n"})}),"\n",(0,n.jsx)(s.p,{children:"The above code should output 'G' because there is only two transition and so action 2 which index the third transition does not exist."}),"\n",(0,n.jsx)(s.h2,{id:"search-trees",children:"Search Trees"}),"\n",(0,n.jsx)(s.p,{children:"Our state-space search can be represented as a search tree having the starting state as its root. For example, if we want to search path from state S to state D, we can draw the following search tree."}),"\n",(0,n.jsx)(r.A,{path:a(28236).A,widthPercentage:"70%"}),"\n",(0,n.jsxs)(s.p,{children:["In the above tree, we label the edges with the input action that one takes from one state to another state following the ",(0,n.jsx)(s.code,{children:"statemap"})," dictionary in the previous section. If we can build this tree, we can find the path from S to D and we know that we need to take the following actions:"]}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsx)(s.li,{children:"Take 0 from S to reach B"}),"\n",(0,n.jsx)(s.li,{children:"Take 1 from B to reach D\nor we can also take the following sequence of actions:"}),"\n",(0,n.jsx)(s.li,{children:"Take 1 from S to reach A"}),"\n",(0,n.jsx)(s.li,{children:"Take 2 from A to reach D"}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"class-searchnode",children:"Class SearchNode"}),"\n",(0,n.jsxs)(s.p,{children:["We can facilitate this search by creating a class called ",(0,n.jsx)(s.code,{children:"SearchNode"})," that contains the information needed to build the search Trees. The UML diagram for ",(0,n.jsx)(s.code,{children:"SearchNode"})," is shown below."]}),"\n",(0,n.jsx)(s.mermaid,{value:"classDiagram\nclass SearchNode{\n    state\n    action\n    parent\n    path()\n    in_path(state)\n    __eq__(other)\n}"}),"\n",(0,n.jsx)(s.p,{children:"The class has three attributes:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"state, which identifies the node for the particular state it represents in the tree"}),"\n",(0,n.jsx)(s.li,{children:"action, which stores the action it takes from the parent to reach the current node"}),"\n",(0,n.jsx)(s.li,{children:"parent, which stores the reference to the parent node in the search tree"}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"The class has three methods:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"path()"})," which returns the path from the root of the tree to the current node"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"in_path(state)"})," which takes in a state and check if that state is in the path from the root to the current node"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"__eq__(other)"})," which allows us to use the equality operator in Python to check if two nodes are equal"]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"You will work on the implementation of this class in your Problem Set."}),"\n",(0,n.jsx)(s.h2,{id:"state-machine-for-state-space-search",children:"State Machine for State-Space Search"}),"\n",(0,n.jsx)(s.p,{children:"We have been looking into this search problem from the perspective of state machine. This implies that we can create a state machine class to represent a state machine that does state-space search. This class, however, has unique requirements as you need to make sure you have enough information for the problem. This means that you may want to ensure that such class must provide information about the following:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"statemap"}),", which gives you the transition relationship from one state to another with respect to the legal input"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"legal_inputs"}),", which is a set of legal inputs in this domain."]}),"\n"]}),"\n",(0,n.jsxs)(s.p,{children:["We can enforce this in Python using the Abstract Base Class and creating an ",(0,n.jsx)(s.strong,{children:"abstract property"}),". This is a similar concept as how we implement the computed property ",(0,n.jsx)(s.code,{children:"start_state"}),". We can, thus, define the following class:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:"from abc import abstractmethod\n\nclass StateSpaceSearch(StateMachine):\n    @property\n    @abstractmethod\n    def statemap(self):\n        pass\n\n    @property\n    @abstractmethod\n    def legal_inputs(self):\n        pass\n\n    @property\n    @abstractmethod\n    def start_state(self):\n        return self.__start_state\n\n    @start_state.setter\n    @abstrctmethod\n    def start_state(self, value):\n        self.__start_state = value\n\n"})}),"\n",(0,n.jsxs)(s.p,{children:["In the above definition, ",(0,n.jsx)(s.code,{children:"StateSpaceSearch"})," class inherits from ",(0,n.jsx)(s.code,{children:"StateMachine"})," class and it adds the required property ",(0,n.jsx)(s.code,{children:"statemap"})," and ",(0,n.jsx)(s.code,{children:"legal_inputs"}),". Any state machine class implementing ",(0,n.jsx)(s.code,{children:"StateSpaceSearch"})," now must define these two properties and its getter method. The last two abstract methods that we have is simply the getter and the setter of ",(0,n.jsx)(s.code,{children:"start_state"})," computed property which has to be implemented for all ",(0,n.jsx)(s.code,{children:"StateMachine"})," child class. We created a general implementation that sets and returns the attribute ",(0,n.jsx)(s.code,{children:"__start_state"}),". We use Python name mangling with double underscore at the beginning of the variable to keep this attribute hidden."]}),"\n",(0,n.jsxs)(s.p,{children:["So now, what we need to do is simply to implement the two abstract methods, i.e. ",(0,n.jsx)(s.code,{children:"statemap"})," and ",(0,n.jsx)(s.code,{children:"legal_inputs"}),", as well as initializing the ",(0,n.jsx)(s.code,{children:"start_state"})," property. For example, we can initialize the ",(0,n.jsx)(s.code,{children:"start_state"})," property and implement the ",(0,n.jsx)(s.code,{children:"statemap"})," property as follows:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'class MapSM(StateSpaceSearch):\n\n    def __init__(self, start):\n        self.start_state = start\n\n    @property\n    def statemap(self):\n        statemap = {"S": ["A", "B"],\n                    "A": ["S", "C", "D"],\n                    "B": ["S", "D", "E"],\n                    "C": ["A", "F"],\n                    "D": ["A", "B", "F", "H"],\n                    "E": ["B", "H"],\n                    "F": ["C", "D", "G"],\n                    "H": ["D", "E", "G"],\n                    "G": ["F", "H"]}\n        return statemap\n'})}),"\n",(0,n.jsxs)(s.p,{children:["Notice that the ",(0,n.jsx)(s.code,{children:"statemap"})," must be defined in the child class that implements ",(0,n.jsx)(s.code,{children:"StateSpaceSearch"})," because such mapping transition information can be different from one state machine to another. This cannot be defined in the base class."]}),"\n",(0,n.jsxs)(s.p,{children:["Similarly, the computed property ",(0,n.jsx)(s.code,{children:"legal_inputs"})," can take in the information from ",(0,n.jsx)(s.code,{children:"statemap"})," and return a set of the legal inputs. Though we may think that the code to create such a set is the same for all state-space search, it actually depends on how one implements the ",(0,n.jsx)(s.code,{children:"statemap"})," property. If one uses a list as in our case, such set will be a set of integer values. But if one uses a dictionary, the set ",(0,n.jsx)(s.code,{children:"legal_inputs"})," may be a set of other data types used in the key of that dictionary."]}),"\n",(0,n.jsxs)(s.p,{children:["In this state machine the ",(0,n.jsx)(s.code,{children:"start_state"})," is the starting state of our search problem. For example, state 'S' should be initialized as our ",(0,n.jsx)(s.code,{children:"start_state"})," following the previous examples."]}),"\n",(0,n.jsxs)(s.p,{children:["We also need to define our ",(0,n.jsx)(s.code,{children:"get_next_values(state, inp)"})," method. This method should return the next state and the output of our search transition. In our state-space search, the output is usually the same as the next state, which is what state should the machine go to given the current state and the input action. In fact, this function is exactly what a successor function ",(0,n.jsx)(s.code,{children:"statemap_successor(state, action)"})," does in our previous discussion. This means that you can implement your ",(0,n.jsx)(s.code,{children:"get_next_values(state, inp)"})," method using the information you have from ",(0,n.jsx)(s.code,{children:"statemap"})," and ",(0,n.jsx)(s.code,{children:"legal_inputs"}),". Remember to ensure that if the input is not valid for that current state, it should remain in the current state. And now you have a complete state machine to do state-space search."]}),"\n",(0,n.jsxs)(s.p,{children:["You can write your breadth-first search algorithm and makes use of the ",(0,n.jsx)(s.code,{children:"get_next_values()"})," of the state machine to find a path from the starting state to the goal state. You will do this in your Problem Set."]})]})}function p(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);