"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[6015],{33926:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>x,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"heap-complexity/heapsort","title":"Heapsort","description":"Heapsort is a comparison-based sorting algorithm that builds a binary heap data structure and repeatedly extracts the maximum element to sort a given array.","source":"@site/docs/02-heap-complexity/heapsort.md","sourceDirName":"02-heap-complexity","slug":"/heap-complexity/heapsort","permalink":"/2023/notes/heap-complexity/heapsort","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Binary Heap","permalink":"/2023/notes/heap-complexity/binary-heap"},"next":{"title":"Computation Time","permalink":"/2023/notes/heap-complexity/computation-time"}}');var r=s(74848),i=s(28453),a=(s(28548),s(13358)),h=(s(73627),s(53833));const l={sidebar_position:2},o="Heapsort",d={},c=[{value:"Goals",id:"goals",level:3},{value:"Introduction",id:"introduction",level:2},{value:"(P)roblem Statement",id:"problem-statement",level:3},{value:"Test (C)ases",id:"test-cases",level:3},{value:"(D)esign of Algorithm",id:"design-of-algorithm",level:3}];function p(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"heapsort",children:"Heapsort"})}),"\n",(0,r.jsx)(h.A,{}),"\n",(0,r.jsx)(n.p,{children:"Heapsort is a comparison-based sorting algorithm that builds a binary heap data structure and repeatedly extracts the maximum element to sort a given array."}),"\n",(0,r.jsx)(n.h3,{id:"goals",children:"Goals"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this lesson, you should be able to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Implement ",(0,r.jsx)(n.strong,{children:"heapsort"})," using iteration."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"Keywords",type:"keyword",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"binary heap"}),", ",(0,r.jsx)(n.code,{children:"heap property"}),", ",(0,r.jsx)(n.code,{children:"heapify"}),",",(0,r.jsx)(n.code,{children:"heapsort"})]})}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["Now, we can consider the Heapsort algorithm. The idea of heapsort is pretty simple. For any arbitrary array, we can sort the integers in the array by first building a ",(0,r.jsx)(n.em,{children:"max-heap"}),". Once the max-heap is built, we know that the maximum is at the ",(0,r.jsx)(n.em,{children:"root"})," node. With this, we can swap the ",(0,r.jsx)(n.em,{children:"root"})," node with the last element and then exclude it from our heap. We then should restore the ",(0,r.jsx)(n.em,{children:"max-heap property"})," after this swap because now the ",(0,r.jsx)(n.em,{children:"root"})," node will be a small number. We can do this repetitively until there is no more element in the heap."]}),"\n",(0,r.jsx)(n.h3,{id:"problem-statement",children:"(P)roblem Statement"}),"\n",(0,r.jsx)(n.p,{children:"Given an arbitrary array of integers, sort the element using heapsort algorithm."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: array of integers\nOutput: None\nProcess: Sort the elements of the array in place using heapsort\n"})}),"\n",(0,r.jsx)(n.h3,{id:"test-cases",children:"Test (C)ases"}),"\n",(0,r.jsx)(n.p,{children:"Let's use the same example as in the previous section. Let's say we have the following array."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"[1, 2, 8, 7, 14, 9, 3, 10, 4, 16]"})}),"\n",(0,r.jsx)(n.p,{children:"We will sort the elements following these steps:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Build a max-heap from this array. The previous section has shown that the final output of building a max-heap will be:"}),"\n",(0,r.jsx)(n.p,{children:"[16, 14, 9, 10, 2, 8, 3, 7, 4, 1]"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Now, we will swap the largest element with the last element, and exclude it from the heap. We will put the excluded element in what we called as ",(0,r.jsx)(n.strong,{children:"sorted"})," of the list. This sorted section is separated by ",(0,r.jsx)(n.code,{children:"||"})," in the list below."]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"1"}),", 14, 9, 10, 2, 8, 3, 7, 4 ,|| ",(0,r.jsx)(n.strong,{children:"16"}),"]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Notice, now, that the array does not satisfy the ",(0,r.jsx)(n.em,{children:"max-heap property"}),". So we must ",(0,r.jsx)(n.em,{children:"max-heapify"})," the array to push the element 1 down to its place. The process of ",(0,r.jsx)(n.em,{children:"max-heapify"})," from the root node will result in:"]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"1"}),", ",(0,r.jsx)(n.strong,{children:"14"}),", 9, 10, 2, 8, 3, 7, 4, || 16]"]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"14"}),", ",(0,r.jsx)(n.strong,{children:"1"}),", 9, 10, 2, 8, 3, 7, 4, || 16]"]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [14, ",(0,r.jsx)(n.strong,{children:"10"}),", 9, ",(0,r.jsx)(n.strong,{children:"1"}),", 2, 8, 3, 7, 4, || 16]"]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [14, 10, 9, ",(0,r.jsx)(n.strong,{children:"7"}),", 2, 8, 3, ",(0,r.jsx)(n.strong,{children:"1"}),", 4, || 16]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Once we have restored the ",(0,r.jsx)(n.em,{children:"max-heap property"}),", we can take out the largest element from the first element and swap it with the last element in the heap."]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"4"}),", 10, 9, 7, 2, 8, 3, 1, || ",(0,r.jsx)(n.strong,{children:"14"}),", 16]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["We then ",(0,r.jsx)(n.em,{children:"max-heapify"})," the heap again to restore the ",(0,r.jsx)(n.em,{children:"max-heap property"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"4"}),", ",(0,r.jsx)(n.strong,{children:"10"}),", 9, 7, 2, 8, 3, 1, || ",(0,r.jsx)(n.strong,{children:"14"}),", 16]"]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"10"}),", ",(0,r.jsx)(n.strong,{children:"4"}),", 9, 7, 2, 8, 3, 1, || ",(0,r.jsx)(n.strong,{children:"14"}),", 16]"]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [10, ",(0,r.jsx)(n.strong,{children:"7"}),", 9, ",(0,r.jsx)(n.strong,{children:"4"}),", 2, 8, 3, 1, || ",(0,r.jsx)(n.strong,{children:"14"}),", 16]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"We then swap the largest element with the last element in the heap, and take it out from the heap."}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"1"}),", 7, 9, 4, 2, 8, 3, || ",(0,r.jsx)(n.strong,{children:"10"}),", 14, 16]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["The same process of ",(0,r.jsx)(n.em,{children:"max-heapify"})," happens again. We will now ",(0,r.jsx)(n.em,{children:"remove"})," the intermediate step and only show the first and the final state of the heaps."]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"1"}),", 7, 9, 4, 2, 8, 3, || ",(0,r.jsx)(n.strong,{children:"10"}),", 14, 16]"]}),"\n",(0,r.jsxs)(n.p,{children:["heap = [9, 7, 8, 4, 2, ",(0,r.jsx)(n.strong,{children:"1"}),", 3, || ",(0,r.jsx)(n.strong,{children:"10"}),", 14, 16]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"We swap and take out again the largest element. The next iteration would be:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"3"}),", 7, 8, 4, 2, ",(0,r.jsx)(n.strong,{children:"1"}),", || ",(0,r.jsx)(n.strong,{children:"9"}),", 10, 14, 16]"]}),"\n",(0,r.jsx)(n.p,{children:"then we max-heapify the array:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [8, 7, ",(0,r.jsx)(n.strong,{children:"3"}),", 4, 2, 1, || ",(0,r.jsx)(n.strong,{children:"9"}),", 10, 14, 16]"]}),"\n",(0,r.jsx)(n.p,{children:"Swapping and taking out the largest element:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"1"}),", 7, 3, 4, 2, || ",(0,r.jsx)(n.strong,{children:"8"}),", 9, 10, 14, 16]"]}),"\n",(0,r.jsx)(n.p,{children:"and max-heapify:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [7, 4, 3, ",(0,r.jsx)(n.strong,{children:"1"}),", 2, || ",(0,r.jsx)(n.strong,{children:"8"}),", 9, 10, 14, 16]"]}),"\n",(0,r.jsx)(n.p,{children:"Swapping and taking out the largest element:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"2"}),", 4, 3, 1, || ",(0,r.jsx)(n.strong,{children:"7"}),", 8, 9, 10, 14, 16]"]}),"\n",(0,r.jsx)(n.p,{children:"and max-heapify:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [4, ",(0,r.jsx)(n.strong,{children:"2"}),", 3, 1, || ",(0,r.jsx)(n.strong,{children:"7"}),", 8, 9, 10, 14, 16]"]}),"\n",(0,r.jsx)(n.p,{children:"Swapping and taking out the largest element:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"1"}),", 2, 3, || ",(0,r.jsx)(n.strong,{children:"4"}),", 7, 8, 9, 10, 14, 16]"]}),"\n",(0,r.jsx)(n.p,{children:"and max-heapify:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [3, 2, ",(0,r.jsx)(n.strong,{children:"1"}),", || ",(0,r.jsx)(n.strong,{children:"4"}),", 7, 8, 9, 10, 14, 16]"]}),"\n",(0,r.jsx)(n.p,{children:"Swapping and taking out the largest element:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"1"}),", 2, || ",(0,r.jsx)(n.strong,{children:"3"}),", 4, 7, 8, 9, 10, 14, 16]"]}),"\n",(0,r.jsx)(n.p,{children:"and max-heapify:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [2, ",(0,r.jsx)(n.strong,{children:"1"}),", || ",(0,r.jsx)(n.strong,{children:"3"}),", 4, 7, 8, 9, 10, 14, 16]"]}),"\n",(0,r.jsx)(n.p,{children:"Swapping and taking out the largest element:"}),"\n",(0,r.jsxs)(n.p,{children:["heap = [",(0,r.jsx)(n.strong,{children:"1"}),", || ",(0,r.jsx)(n.strong,{children:"2"}),", 3, 4, 7, 8, 9, 10, 14, 16]"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["At this point in time, the array is already sorted. If ",(0,r.jsx)(n.code,{children:"heap"})," and ",(0,r.jsx)(n.code,{children:"sorted"})," are not a separate array but rather one single array, we will have:"]}),"\n",(0,r.jsx)(n.p,{children:"result = [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"design-of-algorithm",children:"(D)esign of Algorithm"}),"\n",(0,r.jsx)(n.p,{children:"Let's write down the steps in the previous section in a pseudocode."}),"\n",(0,r.jsx)(a.A,{title:"Show Pseudocode",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"def heapsort(array):\nInput:\n  - array: any arbitrary array\nOutput: None\nSteps:\n1. call build-max-heap(array)\n2. heap_end_pos = length of array - 1 # index of the last element in the heap\n3. As long as (heap_end_pos > 0), do:\n    3.1 swap( array[0], array[heap_end_pos])\n    3.2 heap_end_pos = heap_end_pos -1 # reduce heap size\n    3.3 call max-heapify(array[from index 0 to heap_end_pos inclusive], 0)\n"})})}),"\n",(0,r.jsxs)(n.p,{children:["We first call the procedure in the previous section called ",(0,r.jsx)(n.code,{children:"build-max-heap"})," to create the ",(0,r.jsx)(n.em,{children:"max-heap"})," data structure. We then start from the last element in the heap and swap it with the largest element (always at index 0)."]}),"\n",(0,r.jsxs)(n.p,{children:["We reduce the variable ",(0,r.jsx)(n.code,{children:"heap_end_pos"})," to reduce the heap size and exclude the largest element from the heap."]}),"\n",(0,r.jsxs)(n.p,{children:["Then, we can call ",(0,r.jsx)(n.code,{children:"max-heapify"})," on a subarray. The subarray starts from index 0 of the current array up to index ",(0,r.jsx)(n.code,{children:"heap_end_pos"}),". In this way, we exclude the largest element from being ",(0,r.jsx)(n.em,{children:"max-heapified"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The second argument of ",(0,r.jsx)(n.code,{children:"max-heapify"})," is the starting node where the process should begins. In this case, we always want to start ",(0,r.jsx)(n.code,{children:"max-heapify"})," from index 0 because this is the node where we replace the largest element with some small element from the end of the heap."]})]})}function x(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}}}]);