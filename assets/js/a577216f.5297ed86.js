"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[5044],{52231:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Syllabus","href":"/2023/notes/introduction","docId":"introduction","unlisted":false},{"type":"category","label":"Week 1: Sorting Algorithms","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Bubble Sort","href":"/2023/notes/sorting-algorithms/bubble-sort","docId":"sorting-algorithms/bubble-sort","unlisted":false},{"type":"link","label":"Insertion Sort","href":"/2023/notes/sorting-algorithms/insertion-sort","docId":"sorting-algorithms/insertion-sort","unlisted":false}],"href":"/2023/notes/category/week-1-sorting-algorithms"},{"type":"category","label":"Week 2: Analysing Programs","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Binary Heap","href":"/2023/notes/heap-complexity/binary-heap","docId":"heap-complexity/binary-heap","unlisted":false},{"type":"link","label":"Heapsort","href":"/2023/notes/heap-complexity/heapsort","docId":"heap-complexity/heapsort","unlisted":false},{"type":"link","label":"Computation Time","href":"/2023/notes/heap-complexity/computation-time","docId":"heap-complexity/computation-time","unlisted":false}],"href":"/2023/notes/category/week-2-analysing-programs"},{"type":"category","label":"Week 3: Divide and Conquer","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Recursion","href":"/2023/notes/divide-and-conquer/divide-and-conquer","docId":"divide-and-conquer/divide-and-conquer","unlisted":false},{"type":"link","label":"Merge Sort","href":"/2023/notes/divide-and-conquer/merge-sort","docId":"divide-and-conquer/merge-sort","unlisted":false}],"href":"/2023/notes/category/week-3-divide-and-conquer"},{"type":"category","label":"Week 4: Object-Oriented Paradigm","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Object Oriented Programming","href":"/2023/notes/oop/oop","docId":"oop/oop","unlisted":false},{"type":"link","label":"Linear Data Structures","href":"/2023/notes/oop/linear-dt","docId":"oop/linear-dt","unlisted":false}],"href":"/2023/notes/category/week-4-object-oriented-paradigm"},{"type":"category","label":"Week 5: OOP and Inheritance","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Computation as Object","href":"/2023/notes/oop-inheritance/oop-computation","docId":"oop-inheritance/oop-computation","unlisted":false},{"type":"link","label":"Inheritance","href":"/2023/notes/oop-inheritance/inheritance","docId":"oop-inheritance/inheritance","unlisted":false},{"type":"link","label":"Abstract Base Class","href":"/2023/notes/oop-inheritance/abc","docId":"oop-inheritance/abc","unlisted":false},{"type":"link","label":"Fixed-Size Array and Linked List","href":"/2023/notes/oop-inheritance/array-linkedlist","docId":"oop-inheritance/array-linkedlist","unlisted":false}],"href":"/2023/notes/category/week-5-oop-and-inheritance"},{"type":"category","label":"Week 6: Graph Traversal","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Basics of Graph","href":"/2023/notes/graph-traversal/basics-graph","docId":"graph-traversal/basics-graph","unlisted":false},{"type":"link","label":"Breadth First Search","href":"/2023/notes/graph-traversal/bfs","docId":"graph-traversal/bfs","unlisted":false},{"type":"link","label":"Depth First Search","href":"/2023/notes/graph-traversal/dfs","docId":"graph-traversal/dfs","unlisted":false}],"href":"/2023/notes/category/week-6-graph-traversal"},{"type":"category","label":"Week 8: Design of State Machines","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"State Machine","href":"/2023/notes/sm/state-machine","docId":"sm/state-machine","unlisted":false},{"type":"link","label":"SM Abstract Base Class","href":"/2023/notes/sm/state-machine-abc","docId":"sm/state-machine-abc","unlisted":false},{"type":"link","label":"State Space Search","href":"/2023/notes/sm/state-space-search","docId":"sm/state-space-search","unlisted":false}],"href":"/2023/notes/category/week-8-design-of-state-machines"},{"type":"category","label":"Week 9: Visualizing and Processing Data","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Working With Data","href":"/2023/notes/data-visualization/working-with-data","docId":"data-visualization/working-with-data","unlisted":false},{"type":"link","label":"NumPy Array","href":"/2023/notes/data-visualization/numpy-array","docId":"data-visualization/numpy-array","unlisted":false},{"type":"link","label":"Visualization","href":"/2023/notes/data-visualization/visualisation","docId":"data-visualization/visualisation","unlisted":false}],"href":"/2023/notes/category/week-9-visualizing-and-processing-data"},{"type":"category","label":"Week 10: Modeling Continuous Data","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Linear Regression","href":"/2023/notes/regression/linear-regresion","docId":"regression/linear-regresion","unlisted":false},{"type":"link","label":"Multiple Linear Regression","href":"/2023/notes/regression/multiple-linear-regression","docId":"regression/multiple-linear-regression","unlisted":false}],"href":"/2023/notes/category/week-10-modeling-continuous-data"},{"type":"category","label":"Week 11: Classifying Categorical Data","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Logistic Regression","href":"/2023/notes/classification/logistic-regression","docId":"classification/logistic-regression","unlisted":false},{"type":"link","label":"Metrics","href":"/2023/notes/classification/metrics","docId":"classification/metrics","unlisted":false}],"href":"/2023/notes/category/week-11-classifying-categorical-data"}]},"docs":{"classification/logistic-regression":{"id":"classification/logistic-regression","title":"Logistic Regression","description":"Logistic regression is a statistical technique used to model and predict the probability of a binary outcome based on one or more independent variables.","sidebar":"tutorialSidebar"},"classification/metrics":{"id":"classification/metrics","title":"Metrics","description":"Machine learning metrics are quantitative measures used to evaluate the performance of a machine learning model, and a confusion matrix is a specific type of metric that provides a comprehensive summary of the model\'s predictions by comparing them to the actual class labels.","sidebar":"tutorialSidebar"},"data-visualization/numpy-array":{"id":"data-visualization/numpy-array","title":"NumPy Array","description":"In the subsequent lessons, we will work with NumPy array instead of Pandas dataframe. Pandas dataframe is based on Numpy\'s array and many of the operations are similar between the two. However, there are some differences as well.","sidebar":"tutorialSidebar"},"data-visualization/visualisation":{"id":"data-visualization/visualisation","title":"Visualization","description":"Data visualization using Matplotlib and Seaborn in Python enables the creation of informative and visually appealing plots, charts, and graphs, facilitating the exploration, understanding, and communication of patterns, trends, and insights within data.","sidebar":"tutorialSidebar"},"data-visualization/working-with-data":{"id":"data-visualization/working-with-data","title":"Working With Data","description":"Python Pandas is a powerful open-source library that provides high-performance data structures and data analysis tools, making it a popular choice for data manipulation, cleaning, analysis, and visualization tasks.","sidebar":"tutorialSidebar"},"divide-and-conquer/divide-and-conquer":{"id":"divide-and-conquer/divide-and-conquer","title":"Recursion","description":"Recursion is a programming technique in which a function calls itself to solve a problem by breaking it down into smaller subproblems.","sidebar":"tutorialSidebar"},"divide-and-conquer/merge-sort":{"id":"divide-and-conquer/merge-sort","title":"Merge Sort","description":"Merge Sort is another sorting algorithm that implements the principle of divide and conquer.","sidebar":"tutorialSidebar"},"graph-traversal/basics-graph":{"id":"graph-traversal/basics-graph","title":"Basics of Graph","description":"Graph theory is a mathematical discipline that studies the properties and relationships of graphs, which consist of nodes (vertices) connected by edges, enabling analysis of various real-world systems and phenomena.","sidebar":"tutorialSidebar"},"graph-traversal/bfs":{"id":"graph-traversal/bfs","title":"Breadth First Search","description":"Breadth-first search (BFS) is a fundamental graph traversal algorithm widely used in Artificial Intelligence (AI) for finding the shortest path between nodes in a graph. BFS explores all vertices at the present depth level before moving on to vertices at the next depth level, ensuring that the shortest path to each vertex is discovered first. This characteristic makes BFS particularly useful in AI applications where optimal solutions are required. For example, in navigation systems like Google Maps, BFS is employed to determine the shortest route between two locations. When a user inputs a starting point and a destination, BFS calculates the shortest path by systematically exploring all possible routes and selecting the one with the minimum number of steps or distance. Another concrete example is in social network analysis, where BFS can be used to find the shortest connection path between two individuals, helping to identify degrees of separation and influential nodes within the network. Additionally, BFS is utilized in AI for solving puzzles and games, such as the shortest path to solve a maze or the optimal sequence of moves in board games. Overall, BFS is a powerful tool in AI for efficiently solving problems that require finding the shortest path in complex graphs.","sidebar":"tutorialSidebar"},"graph-traversal/dfs":{"id":"graph-traversal/dfs","title":"Depth First Search","description":"Depth-first search (DFS) is a crucial graph traversal algorithm that explores as far as possible along each branch before backtracking. This depth-wise exploration makes DFS particularly effective for tasks such as topological sorting, cycle detection, and solving puzzles. Topological sorting is used to order tasks based on dependencies, ensuring that prerequisite tasks are completed first. For example, in project management software, DFS can help determine the sequence of tasks to optimize workflow. Cycle detection is another important application, where DFS identifies cycles in graphs, which is essential for detecting deadlocks in operating systems or circular dependencies in software packages. Additionally, DFS is employed in solving puzzles with a unique solution, such as mazes or Sudoku. By systematically exploring all possible paths, DFS can find the correct sequence of moves to solve the puzzle.","sidebar":"tutorialSidebar"},"heap-complexity/binary-heap":{"id":"heap-complexity/binary-heap","title":"Binary Heap","description":"Binary heap is a complete binary tree-based data structure that satisfies the heap property, where the key of each parent node is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the keys of its child nodes.","sidebar":"tutorialSidebar"},"heap-complexity/computation-time":{"id":"heap-complexity/computation-time","title":"Computation Time","description":"Computation time, also known as runtime or execution time, refers to the amount of time taken by a computer program or algorithm to complete its execution, typically measured in seconds or milliseconds.","sidebar":"tutorialSidebar"},"heap-complexity/heapsort":{"id":"heap-complexity/heapsort","title":"Heapsort","description":"Heapsort is a comparison-based sorting algorithm that builds a binary heap data structure and repeatedly extracts the maximum element to sort a given array.","sidebar":"tutorialSidebar"},"introduction":{"id":"introduction","title":"Syllabus","description":"This page summarises the links to all notes that are relevant to 10.020. Please read them carefully by the weeks stipulated. You will learn each of the big topics above in the following weeks:","sidebar":"tutorialSidebar"},"oop-inheritance/abc":{"id":"oop-inheritance/abc","title":"Abstract Base Class","description":"This topic is optional and no longer included in the syllabus.","sidebar":"tutorialSidebar"},"oop-inheritance/array-linkedlist":{"id":"oop-inheritance/array-linkedlist","title":"Fixed-Size Array and Linked List","description":"In this lesson we will detour a little bit to discuss two kinds of list. One is a Fixed Size Array and the other one is a Linked List. Both are list but they have their differences.","sidebar":"tutorialSidebar"},"oop-inheritance/inheritance":{"id":"oop-inheritance/inheritance","title":"Inheritance","description":"In Python, inheritance in classes allows a child class to inherit and extend the attributes and methods of a parent class.","sidebar":"tutorialSidebar"},"oop-inheritance/oop-computation":{"id":"oop-inheritance/oop-computation","title":"Computation as Object","description":"Object-oriented programming is a programming paradigm that organizes code into objects, which encapsulate data and behavior, fostering modularity, reusability, and easier maintenance of software systems.","sidebar":"tutorialSidebar"},"oop/linear-dt":{"id":"oop/linear-dt","title":"Linear Data Structures","description":"A linear data structure is a collection of elements where each element has a direct successor and predecessor, forming a sequential arrangement.","sidebar":"tutorialSidebar"},"oop/oop":{"id":"oop/oop","title":"Object Oriented Programming","description":"Object-oriented programming (OOP) is a programming paradigm that organizes code into objects, which encapsulate data and behavior, fostering modularity, reusability, and easier maintenance of software systems. OOP plays a crucial role in structuring AI software systems by emphasizing modularity, reusability, and maintenance. In AI, OOP allows developers to create complex systems by defining classes that encapsulate data and behavior, fostering a clear and organized code structure. For instance, in a machine learning project, different components such as data preprocessing, model training, and evaluation can be encapsulated into distinct classes. This modular approach enables developers to reuse code across various projects, enhancing efficiency and reducing redundancy. Additionally, OOP facilitates easier maintenance and scalability of AI systems. When updates or modifications are needed, changes can be made to specific classes without affecting the entire system. For example, if a new algorithm needs to be integrated, it can be added as a new class or method within an existing class, ensuring seamless integration. Furthermore, OOP supports inheritance, allowing new classes to inherit properties and methods from existing ones, promoting code reuse and reducing development time. Overall, OOP provides a robust framework for developing AI systems that are modular, maintainable, and scalable.","sidebar":"tutorialSidebar"},"regression/linear-regresion":{"id":"regression/linear-regresion","title":"Linear Regression","description":"Linear regression is a statistical modeling technique that seeks to establish a linear relationship between a dependent variable and one or more independent variables.","sidebar":"tutorialSidebar"},"regression/multiple-linear-regression":{"id":"regression/multiple-linear-regression","title":"Multiple Linear Regression","description":"Multiple linear regression is a statistical technique used to model the relationship between a dependent variable and multiple independent variables by fitting a linear equation to the observed data.","sidebar":"tutorialSidebar"},"sm/state-machine":{"id":"sm/state-machine","title":"State Machine","description":"State machines are powerful computational models that describe system behavior through a series of states and transitions based on inputs and conditions. In Artificial Intelligence (AI), state machines are essential for designing systems that require precise control and predictable behavior. For instance, in robotics, state machines can manage the robot\'s actions by defining states such as \\"idle,\\" \\"moving,\\" \\"obstacle detected,\\" and \\"avoiding obstacle,\\" with transitions based on sensor inputs. This ensures the robot responds appropriately to its environment. Another example is in game development, where state machines control character behavior, such as transitioning between states like \\"walking,\\" \\"running,\\" \\"jumping,\\" and \\"attacking,\\" based on user inputs or game events. Additionally, state machines are used in natural language processing to manage dialogue systems, where the AI transitions between states like \\"greeting,\\" \\"asking for information,\\" \\"providing information,\\" and \\"closing conversation,\\" ensuring coherent and contextually appropriate interactions. These applications demonstrate how state machines provide a structured approach to managing complex behaviors in AI systems, enabling reliable and efficient performance.","sidebar":"tutorialSidebar"},"sm/state-machine-abc":{"id":"sm/state-machine-abc","title":"SM Abstract Base Class","description":"An abstract base class in Python is a class that cannot be instantiated and serves as a blueprint for creating subclasses, defining common methods, and enforcing specific behavior.","sidebar":"tutorialSidebar"},"sm/state-space-search":{"id":"sm/state-space-search","title":"State Space Search","description":"State-space search is a technique that involves systematically exploring possible states within a state machine to find optimal solutions. This method is crucial for planning and problem-solving tasks, where the goal is to navigate from an initial state to a desired goal state through a series of transitions. In AI, state-space search is employed in various applications, such as automated planning in robotics, where the robot must determine the sequence of actions to achieve a specific task. For example, a robot navigating a warehouse to pick and place items uses state-space search to plan its path efficiently, avoiding obstacles and optimizing its route. Another application is in game AI, where state-space search helps in solving puzzles or strategizing moves. For instance, in chess, the AI explores different board configurations to determine the best sequence of moves leading to a checkmate. Additionally, state-space search is used in natural language processing for parsing sentences, where the AI systematically explores different syntactic structures to understand and generate coherent text. These examples illustrate how state-space search enables AI systems to make intelligent decisions by thoroughly examining all possible states and transitions to find the most effective solutions.","sidebar":"tutorialSidebar"},"sorting-algorithms/bubble-sort":{"id":"sorting-algorithms/bubble-sort","title":"Bubble Sort","description":"Bubble sort is a simple comparison-based sorting algorithm that repeatedly swaps adjacent elements until the list is sorted.","sidebar":"tutorialSidebar"},"sorting-algorithms/insertion-sort":{"id":"sorting-algorithms/insertion-sort","title":"Insertion Sort","description":"Insertion sort is a comparison-based sorting algorithm that builds the final sorted array one element at a time by inserting each element into its correct position within the already sorted portion of the array.","sidebar":"tutorialSidebar"}}}}')}}]);