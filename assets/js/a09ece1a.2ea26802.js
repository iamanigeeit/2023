"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[6380],{18536:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/topological_sort_finishingtime-2e4346e400678429465951a972e41c7a.jpg"},33694:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/dfs_forest-c06883b5422409b295ce3516e28baae7.jpg"},39709:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/dfs_graph-9dc97f1d709f160e242b6a123999ae5e.jpg"},39972:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/topological_sort_graph-ef9638824d3354c02084923254f0d763.jpg"},40352:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/bfs_graph_example-a3c01246bcad91ad23506c95cad9316f.jpg"},67643:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>d,contentTitle:()=>c,default:()=>f,frontMatter:()=>h,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"graph-traversal/dfs","title":"Depth First Search","description":"Depth-first search (DFS) is a crucial graph traversal algorithm that explores as far as possible along each branch before backtracking. This depth-wise exploration makes DFS particularly effective for tasks such as topological sorting, cycle detection, and solving puzzles. Topological sorting is used to order tasks based on dependencies, ensuring that prerequisite tasks are completed first. For example, in project management software, DFS can help determine the sequence of tasks to optimize workflow. Cycle detection is another important application, where DFS identifies cycles in graphs, which is essential for detecting deadlocks in operating systems or circular dependencies in software packages. Additionally, DFS is employed in solving puzzles with a unique solution, such as mazes or Sudoku. By systematically exploring all possible paths, DFS can find the correct sequence of moves to solve the puzzle.","source":"@site/docs/06-graph-traversal/dfs.md","sourceDirName":"06-graph-traversal","slug":"/graph-traversal/dfs","permalink":"/2023/notes/graph-traversal/dfs","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Breadth First Search","permalink":"/2023/notes/graph-traversal/bfs"},"next":{"title":"Week 8: Design of State Machines","permalink":"/2023/notes/category/week-8-design-of-state-machines"}}');var n=t(74848),r=t(28453),o=(t(28548),t(13358)),a=t(73627),l=t(53833);const h={sidebar_position:3},c="Depth First Search",d={},p=[{value:"Goals",id:"goals",level:3},{value:"Depth-First Search",id:"depth-first-search-1",level:2},{value:"(C)ases",id:"cases",level:3},{value:"(D)esign of Algorithm",id:"design-of-algorithm",level:3},{value:"Topological Sort",id:"topological-sort",level:2}];function g(e){const s={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"depth-first-search",children:"Depth First Search"})}),"\n",(0,n.jsx)(l.A,{}),"\n",(0,n.jsx)(s.p,{children:"Depth-first search (DFS) is a crucial graph traversal algorithm that explores as far as possible along each branch before backtracking. This depth-wise exploration makes DFS particularly effective for tasks such as topological sorting, cycle detection, and solving puzzles. Topological sorting is used to order tasks based on dependencies, ensuring that prerequisite tasks are completed first. For example, in project management software, DFS can help determine the sequence of tasks to optimize workflow. Cycle detection is another important application, where DFS identifies cycles in graphs, which is essential for detecting deadlocks in operating systems or circular dependencies in software packages. Additionally, DFS is employed in solving puzzles with a unique solution, such as mazes or Sudoku. By systematically exploring all possible paths, DFS can find the correct sequence of moves to solve the puzzle."}),"\n",(0,n.jsx)(s.p,{children:"Depth-first search (DFS) is a versatile algorithm with numerous applications in Artificial Intelligence (AI). Here are some examples of how DFS is used in AI:"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Pathfinding in Games"}),":"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"DFS is used to explore possible moves in games like chess or checkers. By traversing the game tree deeply, AI can evaluate potential strategies and determine the best move to make."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Web Crawling"}),":"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Search engines use DFS to crawl web pages. Starting from a given URL, DFS explores links deeply to index content, ensuring comprehensive coverage of the web."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Solving Constraint Satisfaction Problems"}),":"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"In problems like Sudoku or the N-Queens puzzle, DFS systematically explores possible configurations to find solutions that satisfy all constraints."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Automated Planning"}),":"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"In AI planning, DFS helps in exploring possible sequences of actions to achieve a goal. This is particularly useful in robotics and automated systems where the algorithm can find optimal paths for task execution."}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(s.li,{children:["\n",(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.strong,{children:"Genetic Algorithms"}),":"]}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"DFS can be employed to explore the search space in genetic algorithms, helping to identify optimal solutions by deeply traversing possible genetic variations."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"These examples illustrate the broad applicability of DFS in AI, from game strategy and web indexing to solving complex puzzles and optimizing neural networks. The depth-wise exploration characteristic of DFS makes it a powerful tool for efficiently tackling a wide range of AI problems."}),"\n",(0,n.jsx)(s.h3,{id:"goals",children:"Goals"}),"\n",(0,n.jsx)(s.p,{children:"By the end of this lesson, you should be able to:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:["explain and implement ",(0,n.jsx)(s.strong,{children:"depth"})," first search."]}),"\n"]}),"\n",(0,n.jsx)(s.admonition,{title:"Keywords",type:"keyword",children:(0,n.jsxs)(s.p,{children:[(0,n.jsx)(s.code,{children:"depth first search"}),", ",(0,n.jsx)(s.code,{children:"topological search"}),", ",(0,n.jsx)(s.code,{children:"colour"}),", ",(0,n.jsx)(s.code,{children:"parent vertex"}),", ",(0,n.jsx)(s.code,{children:"start/finish time"})]})}),"\n",(0,n.jsx)(s.h2,{id:"depth-first-search-1",children:"Depth-First Search"}),"\n",(0,n.jsxs)(s.p,{children:["There is another kind of search that can be done on a graph. This is called ",(0,n.jsx)(s.strong,{children:"depth-first"})," search (DFS). As the name implies, this algorithm explores the neighbouring vertices in a depth-wise manner. DFS is used in topological sorting, scheduling problems, cycle detection in graph and solving puzzles with only one solution such as finding a path in a maze or solving a sudoku puzzle. Let's illustrate this with the same graph as we have seen previously."]}),"\n",(0,n.jsx)(s.h3,{id:"cases",children:"(C)ases"}),"\n",(0,n.jsx)(a.A,{path:t(40352).A,widthPercentage:"20%"}),"\n",(0,n.jsx)(s.p,{children:"In depth-first search, we go down the tree before moving to the next siblings. For example, as we start from A, we look into its neighbouring vertices. So vertex A has two neighbours, i.e. B and D. The depth-first search algorithm will visit one of them, say vertex B. After it visits B, it will explore one of the neighbours of B instead of visiting D. This is illustrated below."}),"\n",(0,n.jsx)(a.A,{path:t(39709).A,widthPercentage:"40%"}),"\n",(0,n.jsxs)(s.p,{children:["In the figures above, every time we visit a vertex, we put a timestamp on that vertex called ",(0,n.jsx)(s.strong,{children:"discovery time"}),". Once we finish visiting all the neighbours of that vertex, we put another timestamp called ",(0,n.jsx)(s.strong,{children:"finishing time"}),". For example, vertex A has a discovery time 1 and finishing time 12 as indicated by 1/12 in the figure."]}),"\n",(0,n.jsxs)(s.p,{children:["We also labelled the edges with two different kind of symbols. The solid line edges are called ",(0,n.jsx)(s.strong,{children:"tree edges"}),". These are edges in the depth-first forest. An edge (u, v) is a tree edge if v was first discovered by exploring edge (u, v). For example, the edge (A, B) is a tree edge since B is first discovered by exploring the edge (A, B). On the other hand the edge (A, D) is not a tree edge since D was not first discovered by exploring edge (A, D). Rather, D was first discovered by exploring the edge (C, D)."]}),"\n",(0,n.jsxs)(s.p,{children:["This brings us to the other kind of edges discovered by depth-first search. The dashed line edges are called ",(0,n.jsx)(s.strong,{children:"back edges"}),". These are those edges connected a vertex u to an ancestor v in a depth-first tree. For example, A is an ancestor of D. We can see that because we explore D through A - B - C - D. So the edge connecting D to A is a back edge since it connects D to one of its ancestor. Similarly with the edge (C, F). The depth-first forest is shown below."]}),"\n",(0,n.jsx)(a.A,{path:t(33694).A,widthPercentage:"20%"}),"\n",(0,n.jsx)(s.h3,{id:"design-of-algorithm",children:"(D)esign of Algorithm"}),"\n",(0,n.jsx)(s.p,{children:"Now we can try to write the steps to do depth-first search. We will write the steps using two functions. The first one is called DFS as shown below."}),"\n",(0,n.jsx)(o.A,{title:"Show Pseudocode",children:(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"DFS\nInput:\n- G: graph\nOutput:\n- G: graph with the following attributes marked\n  - colour\n  - discovery time\n  - finishing time\n  - parent\nSteps:\n1. Initialize each vertex as follows:\n  1.1 set colour to white\n  1.2 set parent to NILL\n2. set time to 0\n3. for each vertex in the graph G\n  3.1 if the vertex's colour is white, do:\n    3.1.1 dfs-visit(G, u)\n"})})}),"\n",(0,n.jsx)(s.p,{children:"The above algorithm simply initialize the vertices and go through every vertex to perform the second function DFS-VISIT."}),"\n",(0,n.jsx)(o.A,{title:"Show Pseudocode",children:(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"DFS-Visit\nInput:\n- G: graph\n- u: vertex to visit\nOutput:\n- G: graph with the following attributes marked\n  - colour\n  - discovery time\n  - finishing time\n  - parent\nSteps:\n1. increase time by 1\n2. set current time to be the discovery time for u\n3. set u's colour to gray\n4. for each vertex in u's neighbours, do:\n  4.1 if the vertex's colour is white, do:\n    4.1.1 set u as the parent of the vertex\n    4.1.2 call dfs-visit(G, the current vertex)\n5. set u's colour to black\n6. increase time by 1\n7. set current time to be the finishing time\n"})})}),"\n",(0,n.jsx)(s.p,{children:"This function simply set the discovery time for the visited vertex u and begins to visit all the neighbouring vertices of u. However, it only calls DFS-VISIT if the neighbouring vertices are white, which means these vertices have not been visited yet. Once it finishes visiting all the neighbouring vertices, it marks the vertex u to be black and set the finishing time."}),"\n",(0,n.jsx)(s.h2,{id:"topological-sort",children:"Topological Sort"}),"\n",(0,n.jsx)(s.p,{children:"One application of depth-first search algorithm is to perform a topological sort. For example, if we have list of task with dependencies, we can sort which task should be performed first. The figure below gives an example of this dependencies tasks"}),"\n",(0,n.jsx)(a.A,{path:t(39972).A,widthPercentage:"70%"}),"\n",(0,n.jsx)(s.p,{children:"The figure above shows a directed graph of dependencies between different tasks. For example, the task wearing a pant must be done only after the task of wearing underpant and wearing a shirt. We can use the finishing time of DFS to determine the sequence of tasks."}),"\n",(0,n.jsx)(s.p,{children:"Let's try to perform DFS for the above graph. The discovery time and the finishing time for each task is shown in the figure below."}),"\n",(0,n.jsx)(a.A,{path:t(18536).A,widthPercentage:"70%"}),"\n",(0,n.jsx)(s.p,{children:'In the process of DFS, it somehow starts with "undershirt" and traverse to all the children vertices in the tree, i.e. "pants", "wallets", "belt", and then "shoes". After this, it creates another tree starting from "socks", and then another tree starting from "watch", and finally another tree starting from "underpant". The depth-first forest looks like the figure below.'}),"\n",(0,n.jsx)(a.A,{path:t(70889).A,widthPercentage:"70%"}),"\n",(0,n.jsx)(s.p,{children:"We can re-order the tasks by its finishing time from the largest to the smallest as shown in the figure below."}),"\n",(0,n.jsx)(a.A,{path:t(80703).A,widthPercentage:"100%"}),"\n",(0,n.jsx)(s.p,{children:'The sequence above is based on its finishing time from the largest to the smallest. The first three are independent and their sequence can be interchanged, but subsequently, "shirt" must be done only after "undershirt" task. This sequence may also depends on which vertex the search encounters first. With this in mind, we can write the topological sort steps as follows.'}),"\n",(0,n.jsx)(o.A,{title:"Show Pseudocode",children:(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"Topological-Sort\nInput:\n- G: graph\nOutput:\n- list of sorted vertices\nSteps:\n1. call DFS(G) to compute the finishing time for each vertex in G\n2. sort the vertices based on its finishing time from largest to smallest\n3. return a list of sorted vertices\n"})})})]})}function f(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(g,{...e})}):g(e)}},70889:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/depth_first_forest-ce4da2fc1d5d207cdb5b2d48b31ed294.jpg"},80703:(e,s,t)=>{t.d(s,{A:()=>i});const i=t.p+"assets/images/sorted_graph-bff681b2d78404d2b607a7e53ee33bf1.jpg"}}]);