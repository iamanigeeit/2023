"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[5540],{40129:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Syllabus","href":"/DDW2023/notes/introduction","docId":"introduction","unlisted":false},{"type":"category","label":"Week 1: Sorting Algorithms","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Bubble Sort","href":"/DDW2023/notes/sorting-algorithms/bubble-sort","docId":"sorting-algorithms/bubble-sort","unlisted":false},{"type":"link","label":"Insertion Sort","href":"/DDW2023/notes/sorting-algorithms/insertion-sort","docId":"sorting-algorithms/insertion-sort","unlisted":false}],"href":"/DDW2023/notes/category/week-1-sorting-algorithms"},{"type":"category","label":"Week 2: Analysing Programs","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Binary Heap","href":"/DDW2023/notes/heap-complexity/binary-heap","docId":"heap-complexity/binary-heap","unlisted":false},{"type":"link","label":"Heapsort","href":"/DDW2023/notes/heap-complexity/heapsort","docId":"heap-complexity/heapsort","unlisted":false},{"type":"link","label":"Computation Time","href":"/DDW2023/notes/heap-complexity/computation-time","docId":"heap-complexity/computation-time","unlisted":false}],"href":"/DDW2023/notes/category/week-2-analysing-programs"},{"type":"category","label":"Week 3: Divide and Conquer","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Recursion","href":"/DDW2023/notes/divide-and-conquer/divide-and-conquer","docId":"divide-and-conquer/divide-and-conquer","unlisted":false},{"type":"link","label":"Merge Sort","href":"/DDW2023/notes/divide-and-conquer/merge-sort","docId":"divide-and-conquer/merge-sort","unlisted":false}],"href":"/DDW2023/notes/category/week-3-divide-and-conquer"},{"type":"category","label":"Week 4: Object-Oriented Paradigm","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Object Oriented Programming","href":"/DDW2023/notes/oop/oop","docId":"oop/oop","unlisted":false},{"type":"link","label":"Linear Data Structures","href":"/DDW2023/notes/oop/linear-dt","docId":"oop/linear-dt","unlisted":false}],"href":"/DDW2023/notes/category/week-4-object-oriented-paradigm"},{"type":"category","label":"Week 5: OOP and Inheritance","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Computation as Object","href":"/DDW2023/notes/oop-inheritance/oop-computation","docId":"oop-inheritance/oop-computation","unlisted":false},{"type":"link","label":"Inheritance","href":"/DDW2023/notes/oop-inheritance/inheritance","docId":"oop-inheritance/inheritance","unlisted":false},{"type":"link","label":"Abstract Base Class","href":"/DDW2023/notes/oop-inheritance/abc","docId":"oop-inheritance/abc","unlisted":false},{"type":"link","label":"Fixed-Size Array and Linked List","href":"/DDW2023/notes/oop-inheritance/array-linkedlist","docId":"oop-inheritance/array-linkedlist","unlisted":false}],"href":"/DDW2023/notes/category/week-5-oop-and-inheritance"},{"type":"category","label":"Week 6: Graph Traversal","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Basics of Graph","href":"/DDW2023/notes/graph-traversal/basics-graph","docId":"graph-traversal/basics-graph","unlisted":false},{"type":"link","label":"Breadth First Search","href":"/DDW2023/notes/graph-traversal/bfs","docId":"graph-traversal/bfs","unlisted":false},{"type":"link","label":"Depth First Search","href":"/DDW2023/notes/graph-traversal/dfs","docId":"graph-traversal/dfs","unlisted":false}],"href":"/DDW2023/notes/category/week-6-graph-traversal"},{"type":"category","label":"Week 8: Design of State Machines","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"State Machine","href":"/DDW2023/notes/sm/state-machine","docId":"sm/state-machine","unlisted":false},{"type":"link","label":"SM Abstract Base Class","href":"/DDW2023/notes/sm/state-machine-abc","docId":"sm/state-machine-abc","unlisted":false},{"type":"link","label":"State Space Search","href":"/DDW2023/notes/sm/state-space-search","docId":"sm/state-space-search","unlisted":false}],"href":"/DDW2023/notes/category/week-8-design-of-state-machines"},{"type":"category","label":"Week 9: Visualizing and Processing Data","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Working With Data","href":"/DDW2023/notes/data-visualization/working-with-data","docId":"data-visualization/working-with-data","unlisted":false},{"type":"link","label":"NumPy Array","href":"/DDW2023/notes/data-visualization/numpy-array","docId":"data-visualization/numpy-array","unlisted":false},{"type":"link","label":"Visualization","href":"/DDW2023/notes/data-visualization/visualisation","docId":"data-visualization/visualisation","unlisted":false}],"href":"/DDW2023/notes/category/week-9-visualizing-and-processing-data"},{"type":"category","label":"Week 10: Modeling Continuous Data","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Linear Regression","href":"/DDW2023/notes/regression/linear-regresion","docId":"regression/linear-regresion","unlisted":false},{"type":"link","label":"Multiple Linear Regression","href":"/DDW2023/notes/regression/multiple-linear-regression","docId":"regression/multiple-linear-regression","unlisted":false}],"href":"/DDW2023/notes/category/week-10-modeling-continuous-data"},{"type":"category","label":"Week 11: Classifying Categorical Data","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Logistic Regression","href":"/DDW2023/notes/classification/logistic-regression","docId":"classification/logistic-regression","unlisted":false},{"type":"link","label":"Metrics","href":"/DDW2023/notes/classification/metrics","docId":"classification/metrics","unlisted":false}],"href":"/DDW2023/notes/category/week-11-classifying-categorical-data"}]},"docs":{"classification/logistic-regression":{"id":"classification/logistic-regression","title":"Logistic Regression","description":"Logistic regression is a statistical technique used to model and predict the probability of a binary outcome based on one or more independent variables.","sidebar":"tutorialSidebar"},"classification/metrics":{"id":"classification/metrics","title":"Metrics","description":"Machine learning metrics are quantitative measures used to evaluate the performance of a machine learning model, and a confusion matrix is a specific type of metric that provides a comprehensive summary of the model\'s predictions by comparing them to the actual class labels.","sidebar":"tutorialSidebar"},"data-visualization/numpy-array":{"id":"data-visualization/numpy-array","title":"NumPy Array","description":"In the subsequent lessons, we will work with NumPy array instead of Pandas dataframe. Pandas dataframe is based on Numpy\'s array and many of the operations are similar between the two. However, there are some differences as well.","sidebar":"tutorialSidebar"},"data-visualization/visualisation":{"id":"data-visualization/visualisation","title":"Visualization","description":"Data visualization using Matplotlib and Seaborn in Python enables the creation of informative and visually appealing plots, charts, and graphs, facilitating the exploration, understanding, and communication of patterns, trends, and insights within data.","sidebar":"tutorialSidebar"},"data-visualization/working-with-data":{"id":"data-visualization/working-with-data","title":"Working With Data","description":"Python Pandas is a powerful open-source library that provides high-performance data structures and data analysis tools, making it a popular choice for data manipulation, cleaning, analysis, and visualization tasks.","sidebar":"tutorialSidebar"},"divide-and-conquer/divide-and-conquer":{"id":"divide-and-conquer/divide-and-conquer","title":"Recursion","description":"Recursion is a programming technique in which a function calls itself to solve a problem by breaking it down into smaller subproblems.","sidebar":"tutorialSidebar"},"divide-and-conquer/merge-sort":{"id":"divide-and-conquer/merge-sort","title":"Merge Sort","description":"Merge Sort is another sorting algorithm that implements the principle of divide and conquer.","sidebar":"tutorialSidebar"},"graph-traversal/basics-graph":{"id":"graph-traversal/basics-graph","title":"Basics of Graph","description":"Graph theory is a mathematical discipline that studies the properties and relationships of graphs, which consist of nodes (vertices) connected by edges, enabling analysis of various real-world systems and phenomena.","sidebar":"tutorialSidebar"},"graph-traversal/bfs":{"id":"graph-traversal/bfs","title":"Breadth First Search","description":"Breadth-first search is a graph traversal algorithm that explores all the vertices of a graph at the same level before moving to the next level, ensuring the shortest path to each vertex is discovered first.","sidebar":"tutorialSidebar"},"graph-traversal/dfs":{"id":"graph-traversal/dfs","title":"Depth First Search","description":"Depth First Search is a graph traversal algorithm that explores as far as possible along each branch before backtracking.","sidebar":"tutorialSidebar"},"heap-complexity/binary-heap":{"id":"heap-complexity/binary-heap","title":"Binary Heap","description":"Binary heap is a complete binary tree-based data structure that satisfies the heap property, where the key of each parent node is either greater than or equal to (in a max heap) or less than or equal to (in a min heap) the keys of its child nodes.","sidebar":"tutorialSidebar"},"heap-complexity/computation-time":{"id":"heap-complexity/computation-time","title":"Computation Time","description":"Computation time, also known as runtime or execution time, refers to the amount of time taken by a computer program or algorithm to complete its execution, typically measured in seconds or milliseconds.","sidebar":"tutorialSidebar"},"heap-complexity/heapsort":{"id":"heap-complexity/heapsort","title":"Heapsort","description":"Heapsort is a comparison-based sorting algorithm that builds a binary heap data structure and repeatedly extracts the maximum element to sort a given array.","sidebar":"tutorialSidebar"},"introduction":{"id":"introduction","title":"Syllabus","description":"This page summarises the links to all notes that are relevant to 10.020. Please read them carefully by the weeks stipulated. You will learn each of the big topics above in the following weeks:","sidebar":"tutorialSidebar"},"oop-inheritance/abc":{"id":"oop-inheritance/abc","title":"Abstract Base Class","description":"This topic is optional and no longer included in the syllabus.","sidebar":"tutorialSidebar"},"oop-inheritance/array-linkedlist":{"id":"oop-inheritance/array-linkedlist","title":"Fixed-Size Array and Linked List","description":"In this lesson we will detour a little bit to discuss two kinds of list. One is a Fixed Size Array and the other one is a Linked List. Both are list but they have their differences.","sidebar":"tutorialSidebar"},"oop-inheritance/inheritance":{"id":"oop-inheritance/inheritance","title":"Inheritance","description":"In Python, inheritance in classes allows a child class to inherit and extend the attributes and methods of a parent class.","sidebar":"tutorialSidebar"},"oop-inheritance/oop-computation":{"id":"oop-inheritance/oop-computation","title":"Computation as Object","description":"Object-oriented programming is a programming paradigm that organizes code into objects, which encapsulate data and behavior, fostering modularity, reusability, and easier maintenance of software systems.","sidebar":"tutorialSidebar"},"oop/linear-dt":{"id":"oop/linear-dt","title":"Linear Data Structures","description":"A linear data structure is a collection of elements where each element has a direct successor and predecessor, forming a sequential arrangement.","sidebar":"tutorialSidebar"},"oop/oop":{"id":"oop/oop","title":"Object Oriented Programming","description":"Object-oriented programming is a programming paradigm that organizes code into objects, which encapsulate data and behavior, fostering modularity, reusability, and easier maintenance of software systems.","sidebar":"tutorialSidebar"},"regression/linear-regresion":{"id":"regression/linear-regresion","title":"Linear Regression","description":"Linear regression is a statistical modeling technique that seeks to establish a linear relationship between a dependent variable and one or more independent variables.","sidebar":"tutorialSidebar"},"regression/multiple-linear-regression":{"id":"regression/multiple-linear-regression","title":"Multiple Linear Regression","description":"Multiple linear regression is a statistical technique used to model the relationship between a dependent variable and multiple independent variables by fitting a linear equation to the observed data.","sidebar":"tutorialSidebar"},"sm/state-machine":{"id":"sm/state-machine","title":"State Machine","description":"A state machine is a computational model that describes the behavior of a system by specifying a set of states and transitions between those states based on inputs and conditions.","sidebar":"tutorialSidebar"},"sm/state-machine-abc":{"id":"sm/state-machine-abc","title":"SM Abstract Base Class","description":"An abstract base class in Python is a class that cannot be instantiated and serves as a blueprint for creating subclasses, defining common methods, and enforcing specific behavior.","sidebar":"tutorialSidebar"},"sm/state-space-search":{"id":"sm/state-space-search","title":"State Space Search","description":"State machine state space search refers to the process of systematically exploring and navigating through the possible states of a state machine to find an optimal or desired solution.","sidebar":"tutorialSidebar"},"sorting-algorithms/bubble-sort":{"id":"sorting-algorithms/bubble-sort","title":"Bubble Sort","description":"Bubble sort is a simple comparison-based sorting algorithm that repeatedly swaps adjacent elements until the list is sorted.","sidebar":"tutorialSidebar"},"sorting-algorithms/insertion-sort":{"id":"sorting-algorithms/insertion-sort","title":"Insertion Sort","description":"Insertion sort is a comparison-based sorting algorithm that builds the final sorted array one element at a time by inserting each element into its correct position within the already sorted portion of the array.","sidebar":"tutorialSidebar"}}}}')}}]);