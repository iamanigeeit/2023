"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[8101],{67605:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>c,metadata:()=>o,toc:()=>h});const o=JSON.parse('{"id":"oop-inheritance/oop-computation","title":"Computation as Object","description":"Object-oriented programming is a programming paradigm that organizes code into objects, which encapsulate data and behavior, fostering modularity, reusability, and easier maintenance of software systems.","source":"@site/docs/05-oop-inheritance/oop-computation.md","sourceDirName":"05-oop-inheritance","slug":"/oop-inheritance/oop-computation","permalink":"/2023/notes/oop-inheritance/oop-computation","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Week 5: OOP and Inheritance","permalink":"/2023/notes/category/week-5-oop-and-inheritance"},"next":{"title":"Inheritance","permalink":"/2023/notes/oop-inheritance/inheritance"}}');var n=a(74848),i=a(28453),s=(a(28548),a(13358),a(73627),a(53833));const c={sidebar_position:1},r="Computation as Object",l={},h=[{value:"Goals",id:"goals",level:3},{value:"Main Method",id:"main-method",level:2},{value:"Initializing Computation",id:"initializing-computation",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const t={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"computation-as-object",children:"Computation as Object"})}),"\n",(0,n.jsx)(s.A,{}),"\n",(0,n.jsx)(t.p,{children:"Object-oriented programming is a programming paradigm that organizes code into objects, which encapsulate data and behavior, fostering modularity, reusability, and easier maintenance of software systems."}),"\n",(0,n.jsx)(t.h3,{id:"goals",children:"Goals"}),"\n",(0,n.jsx)(t.p,{children:"By the end of this lesson, you should be able to:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["Use ",(0,n.jsx)(t.strong,{children:"object-oriented programming"})," to implement both data and ",(0,n.jsx)(t.strong,{children:"computation"}),"."]}),"\n"]}),"\n",(0,n.jsx)(t.admonition,{title:"Keywords",type:"keyword",children:(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"object"}),", ",(0,n.jsx)(t.code,{children:"main method"}),", ",(0,n.jsx)(t.code,{children:"composition"})]})}),"\n",(0,n.jsxs)(t.p,{children:["So far we have used object to model and abstract data. For example, we created a new data called ",(0,n.jsx)(t.code,{children:"RobotTurtle"}),". However, even with this usage, we see that ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," actually consists of two things, attributes and methods. Attributes seem like the data that we try to abstract. The methods, however, look more like computation on those data. The object ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," actually contains both ",(0,n.jsx)(t.strong,{children:"data"})," and ",(0,n.jsx)(t.strong,{children:"computation"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["We can also actually use object to model ",(0,n.jsx)(t.strong,{children:"computation"}),". One common way to see this is that our ",(0,n.jsx)(t.em,{children:"overall"})," code is actually a ",(0,n.jsx)(t.em,{children:"computation"}),". Computation is a set of code to manipulate our data. In our example of ",(0,n.jsx)(t.code,{children:"RobotTurtle"}),", this data is useless without any code that interact, manipulate, or make use of this data. We can easily imagine a computation code called ",(0,n.jsx)(t.code,{children:"RobotTurtleSimulation"})," or maybe even ",(0,n.jsx)(t.code,{children:"RobotTurtleGame"})," as our computation. This code actually makes use of our ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," data. The simulation or the game code, may spawn ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," objects, move it around and achieve some objectives of the game. We can see that this computation that interact with ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," can be conceived as another object called ",(0,n.jsx)(t.code,{children:"RobotTurtleGame"}),". This game object ",(0,n.jsx)(t.strong,{children:"has"})," ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," object as its data. This is another example of ",(0,n.jsx)(t.strong,{children:"composition"}),". We can draw its class diagram as follows."]}),"\n",(0,n.jsx)(t.mermaid,{value:"classDiagram\n    RobotTurtleGame *-- RobotTurtle\n"}),"\n",(0,n.jsxs)(t.p,{children:["This class ",(0,n.jsx)(t.code,{children:"RobotTurtleGame"})," may also have its attributes and methods. Every object has attributes and methods. Maybe one of its attributes is a list of ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," objects in the game. What can the game do? Maybe it can ",(0,n.jsx)(t.code,{children:"initialize_game()"}),", ",(0,n.jsx)(t.code,{children:"start_game()"}),", ",(0,n.jsx)(t.code,{children:"check_winner()"}),", and so on. Again, we can represent this class using the class diagram as follows."]}),"\n",(0,n.jsx)(t.mermaid,{value:"classDiagram\nclass RobotTurtleGame {\n    list_turtles: list[RobotTurtle]\n    initialize_game()\n    start_game()\n    check_winner()\n    ...\n}"}),"\n",(0,n.jsxs)(t.p,{children:["In your problem set, you will create both objects that represent data and computation. Some objects like ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," can be easily understood as another data type, while other objects like ",(0,n.jsx)(t.code,{children:"RobotTurtleGame"})," can be more easily seen as computation. Anyway, every object has both data and computation."]}),"\n",(0,n.jsx)(t.h2,{id:"main-method",children:"Main Method"}),"\n",(0,n.jsxs)(t.p,{children:["One characteristic when we represent our whole code as an object is that it usually has a ",(0,n.jsx)(t.strong,{children:"main method"}),". A main method is just a method of the object similar to other methods.  It is called ",(0,n.jsx)(t.em,{children:"main"})," method because usually this is the method that is ",(0,n.jsx)(t.em,{children:"invoked"})," to start the whole computation that the object represents."]}),"\n",(0,n.jsxs)(t.p,{children:["For example, the game using ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," object can be represented as an object called ",(0,n.jsx)(t.code,{children:"RobotTurtleGame"}),". This object can then have a ",(0,n.jsx)(t.em,{children:"main"})," method called ",(0,n.jsx)(t.code,{children:"play()"})," which starts the game. As in any object, you can only use the object after it has been ",(0,n.jsx)(t.em,{children:"instantiated"}),". So a common pattern that you will see is something like the code below."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"# instantiating the object to play the game\ngame: RobotTurtleGame = RobotTurtleGame()\n# starting the game by calling the main method\ngame.play()\n"})}),"\n",(0,n.jsx)(t.h2,{id:"initializing-computation",children:"Initializing Computation"}),"\n",(0,n.jsxs)(t.p,{children:["Every computation usually requires some initialization. This sets up the initial state of the computation. In the example of the ",(0,n.jsx)(t.code,{children:"RobotTurtleGame"}),", we may want to setup the ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," object that can be played in the game. We may want to setup the world that the ",(0,n.jsx)(t.code,{children:"RobotTurtle"})," object can move around."]}),"\n",(0,n.jsxs)(t.p,{children:["There are two ways which we can initialize our computation. If the initialization is always the same, we can put this initialization in the ",(0,n.jsx)(t.code,{children:"__init__()"})," method of our ",(0,n.jsx)(t.code,{children:"RobotTurtleGame"})," class. For example, if the game always allow a certain number of turtles, we can instantiate this object inside the ",(0,n.jsx)(t.code,{children:"__init__()"})," method as shown below."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'class RobotTurtleGame:\n    def __init__(self) -> None:\n        self.robot: RobotTurtle = RobotTurtle("turtle")\n'})}),"\n",(0,n.jsxs)(t.p,{children:["With the above code, a single robot is always created when we instantiate the object ",(0,n.jsx)(t.code,{children:"RobotTurtleGame"}),". We can even use argument to create multiple robots during instantiation of the object."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'class RobotTurtleGame:\n   def __init__(self, number:int=1) -> None:\n        self.robots: list[RobotTurtle] = []\n        for idx in range(number):\n            self.robots.append(RobotTurtle("turtle" + idx)) \n'})}),"\n",(0,n.jsxs)(t.p,{children:["The only consideration about this way of initialization is that this process is executed during the ",(0,n.jsx)(t.em,{children:"instantiation"})," of the computation object."]}),"\n",(0,n.jsxs)(t.p,{children:["The second method of initializing computations happens when the data may be available only later after the object is instantiated. Consider for example if you have a computation class called ",(0,n.jsx)(t.code,{children:"Calculator"}),". After this object is instantiated, you may still wait for the user to enter the mathematical expression that the this object is to compute. To handle this case, we can create a ",(0,n.jsx)(t.em,{children:"method"})," to initialize the state of the object. For example, we can create a method called ",(0,n.jsx)(t.code,{children:"read_input()"})," which takes the value the user enters into the text field of the Calculator."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"class Calculator:\n    ...\n    def read_input(self) -> None:\n        self.expression = self.get_text_input()\n\n    def evaluate(self) -> float:\n        # code to evaluate the expression\n        ...\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In this case, we can only call ",(0,n.jsx)(t.code,{children:"evaluate()"})," after we call ",(0,n.jsx)(t.code,{children:"read_input()"}),"."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"calc: Calculator = Calculator()\n...\ncalc.read_input()\ncalc.evaluate()\n"})}),"\n",(0,n.jsxs)(t.p,{children:["The method ",(0,n.jsx)(t.code,{children:"self.read_input()"})," does not take any argument and it assumes that it has access to the data from another object inside ",(0,n.jsx)(t.code,{children:"Calculator"})," object through ",(0,n.jsx)(t.code,{children:"self.get_text_input()"}),". However, if the data comes not from within ",(0,n.jsx)(t.code,{children:"Calculator"})," object, we may need to have a method that can feed in the data to initialize the attribute of the object before the computation starts. For example, we can have the method ",(0,n.jsx)(t.code,{children:"input()"})," which takes in the mathematical expression as shown below."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:"class Calculator:\n    def input(self, expression: str) -> None:\n        self.expression = expression\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In this way, we use this method to initialize ",(0,n.jsx)(t.code,{children:"expression"})," attribute before we evaluate it."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'calc: Calculator = Calculator()\ncalc.input("3 + 2")\nprint(calc.evaluate())\n'})}),"\n",(0,n.jsxs)(t.p,{children:["In this way, we ensure that ",(0,n.jsx)(t.code,{children:"evaluate()"})," method has data before it peforms its computation."]}),"\n",(0,n.jsx)(t.h2,{id:"summary",children:"Summary"}),"\n",(0,n.jsx)(t.p,{children:"In summary, we can use object to model our overall computation. Similar to any other object, this object contains data and computation. One characteristic of this object is that it usually has one main method that starts the overall computation. This method may call other methods in the process. Before calling the main method, we may need to initialize the attributes of the object to ensure that the data is there for the computation to take place. There are ways to initialize the attributes as shown in this lesson."})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);